import labrad
import numpy as np
from os import environ
from time import sleep
from datetime import datetime
from artiq.experiment import *


class DDSPowerCalibration(EnvExperiment):
    """
    Calibration: DDS Power

    Measure the output power of a given signal (or set of signals) generated by the DDSs.
    """
    # kernel_invariants = {}

    def build(self):
        """
        Set devices and arguments for the experiment.
        """
        self.setattr_device("core")
        self.setattr_device("core_dma")

        # experiment runs
        self.setattr_argument("repetitions",                                    NumberValue(default=5, ndecimals=0, step=1, min=1, max=10000))

        # spectrum analyzer
        self.setattr_argument("spectrum_analyzer_bandwidth_khz",                NumberValue(default=5, ndecimals=3, step=1, min=0.001, max=100000))
        self.setattr_argument("spectrum_analyzer_attenuation_internal_db",      NumberValue(default=1., ndecimals=1, step=10, min=0, max=60))
        self.setattr_argument("spectrum_analyzer_attenuation_external_db",      NumberValue(default=0, ndecimals=1, step=1, min=0, max=1000))

        # set relevant devices
        self.setattr_device("urukul0_cpld")
        self.setattr_device("urukul0_ch1")
        self.setattr_device("urukul0_ch2")
        self.setattr_device("urukul0_ch3")

        self.setattr_device("urukul1_cpld")
        self.setattr_device("urukul1_ch1")
        self.setattr_device("urukul1_ch2")
        self.setattr_device("urukul1_ch3")

        self.setattr_device("urukul2_cpld")
        self.setattr_device("urukul2_ch1")
        self.setattr_device("urukul2_ch2")
        self.setattr_device("urukul2_ch3")

    def prepare(self):
        """
        Prepare things such that kernel functions have minimal overhead.
        """
        # alias relevant devices
        self.dds =          self.urukul0_ch1
        self.dds_cpld =     self.urukul0_cpld

        self.dds_ch1 =      self.urukul0_ch1
        self.dds_ch2 =      self.urukul0_ch2
        self.dds_ch3 =      self.urukul0_ch3

        # import dataset expid
        self.dataset_expid = self.get_dataset('tmpres.isa_demo.filter_expid')
        # np.random.shuffle(self.dataset_expid)
        # convert expid units
        self.dataset_expid *= np.array([MHz, kHz, dB, dB, 0.01, 0.01, 0.01])

        # set up datasets
        self._result_iter = 0
        self.set_dataset("results", np.zeros((len(self.dataset_expid), 10)))
        self.setattr_dataset("results")

        # prepare labrad
        self._prepare_labrad()

    def _prepare_labrad(self):
        """
        Prepare the LabRAD system.
        """
        # connect to labrad
        self.cxn =                                                              labrad.connect(environ['LABRADHOST'], port=7682, tls_mode='off', username='', password='lab')
        self.sa =                                                               self.cxn.spectrum_analyzer_server
        self.dv =                                                               self.cxn.data_vault
        self.cr =                                                               self.cxn.context()

        # set up spectrum analyzer
        # get list of spectrum analyzers
        sa_dev_list = self.sa.list_devices()
        sa_dev_dict = dict(tuple(sa_dev_list))

        # select correct spectrum analyzer
        dev_exists = False
        for dev_num, dev_desc in sa_dev_dict.items():
            # if 'MY500' in dev_desc:
            if 'DSA8' in dev_desc:
                dev_exists = True
                self.sa.select_device(dev_num)

        # raise error if function generator doesn't exist
        if not dev_exists:
            raise Exception("Error: sexy spectrum analyzer not detected.")

        # set up spectrum analyzer sweep
        self.sa.frequency_center(1000000)
        self.sa.attenuation(self.spectrum_analyzer_attenuation_internal_db)
        self.sa.frequency_span(4 * self.spectrum_analyzer_bandwidth_khz * kHz)
        self.sa.bandwidth_resolution(self.spectrum_analyzer_bandwidth_khz * 1000)
        # self.time_sweep_sa_s = float(self.sa.gpib_query('SWE:TIME?'))
        self.time_sweep_sa_s = float(self.sa.gpib_query(':SWE:TIME?'))
        # self.sa.gpib_write('DET:TRAC1 AVER')

        # set up spectrum analyzer marker
        # self.sa.peak_threshold(-90)
        # self.sa.peak_excursion(15)
        self.sa.marker_toggle(1, True)
        # self.sa.gpib_write(':CALC:MARK1:CPS 1')
        # self.sa.gpib_write(':CALC:MARK1:CPE 1')

        # set up display/measurement
        # self.sa.gpib_write('DISP:ENAB 1')
        self.sa.gpib_write(':DISP:ENAB 0')


        # # set up data vault
        # # create labrad dataset title
        # date =                  datetime.now()
        # dataset_title_tmp =     'DDS Power Calibration'
        # trunk =                 '{0:s}_{1:02d}:{2:02d}'.format(dataset_title_tmp, date.hour, date.minute)
        # trunk_tmp =             ['', 'labrad', str(date.year), '{:02d}'.format(date.month), '{0:02d}'.format(date.day), trunk]
        #
        # # create labrad dataset
        # self.dv.cd(trunk_tmp, True, context=self.cr)
        # self.dv.new(
        #     dataset_title_tmp,
        #     [
        #         ('Frequency',       'MHz')
        #     ],
        #     [
        #         ('RSB Power',       'Power',    'dBm'),
        #         ('BSB Power',       'Power',    'dBm'),
        #         ('Carrier Power',   'Power',    'dBm')
        #     ],
        #     context=self.cr
        # )
        # print("Data vault setup successful.")


    @kernel(flags={"fast-math"})
    def _prepare_devices(self):
        """
        Prepare ARTIQ hardware devices.
        """
        # set up DDSs
        self.dds_cpld.set_profile(0)
        self.core.break_realtime()

        self.dds_ch1.sw.on()
        self.dds_ch2.sw.on()
        self.dds_ch3.sw.on()
        self.core.break_realtime()

    @kernel(flags={"fast-math"})
    def run(self):
        """
        Run the experimental sequence.
        """
        self.core.reset()

        # prepare devices
        self._prepare_devices()
        self.core.break_realtime()


        # MAIN SEQUENCE
        # sweep calibration values
        for config_list in self.dataset_expid:

            # separate out values
            freq_carrier_hz =   config_list[0]
            freq_sideband_hz =  config_list[1]
            att_sideband_db =   config_list[2]
            att_carrier_db =    config_list[3]
            ampl_rsb_frac =     config_list[4]
            ampl_bsb_frac =     config_list[5]
            ampl_carrier_frac = config_list[6]


            '''DEVICE SETUP'''
            # set up CH1 (RSB)
            at_mu(now_mu() + 50000)
            self.dds_ch1.set(freq_carrier_hz - freq_sideband_hz, amplitude=ampl_rsb_frac, profile=0)
            self.dds_ch1.set_att(att_sideband_db)

            # set up CH2 (BSB)
            at_mu(now_mu() + 50000)
            self.dds_ch2.set(freq_carrier_hz + freq_sideband_hz, amplitude=ampl_bsb_frac, profile=0)
            self.dds_ch2.set_att(att_sideband_db)

            # set up CH3 (carrier)
            at_mu(now_mu() + 50000)
            self.dds_ch3.set(freq_carrier_hz, amplitude=ampl_carrier_frac, profile=0)
            self.dds_ch3.set_att(att_carrier_db)


            '''MEASURE'''
            # synchronize timeline for RPC
            self.core.wait_until_mu(now_mu())
            delay_mu(2500000)

            # record RSB power
            power_rsb = self.record_power(freq_carrier_hz - freq_sideband_hz)
            self.core.break_realtime()

            # record BSB power
            power_bsb = self.record_power(freq_carrier_hz + freq_sideband_hz)
            self.core.break_realtime()

            # record carrier power
            power_carrier = self.record_power(freq_carrier_hz)
            self.core.break_realtime()

            # record results
            self.update_results(
                freq_carrier_hz,
                freq_sideband_hz,
                att_sideband_db,
                att_carrier_db,
                ampl_rsb_frac,
                ampl_bsb_frac,
                ampl_carrier_frac,
                power_rsb,
                power_bsb,
                power_carrier
            )

        # END
        self.core.break_realtime()


    @rpc
    def record_power(self, peak_freq_hz: TFloat) -> TFloat:
        """
        Get and record the given number of peaks, sorted by amplitude.
        Arguments:
            todo: document
        Returns:
            todo: document
        """
        # zoom in on band of interest
        self.sa.frequency_center(peak_freq_hz)
        # self.sa.gpib_write('CALC:MARK1:X ' + str(peak_freq_hz))
        self.sa.marker_frequency(1, peak_freq_hz)

        # zoom in on amplitude
        self.sa.gpib_write(':POW:ASC')

        # average multiple measurements
        peak_power_dbm_list = np.zeros(self.repetitions)
        num_vals = 0
        while num_vals < self.repetitions:

            # wait for spectrum analyzer sweep to finish before recording data point
            # sleep(1.25 * self.time_sweep_sa_s)
            sleep(0.75)
            power_dbm_tmp = self.sa.marker_amplitude(1)
            # print(power_dbm_tmp)

            # ensure reading is valid
            if power_dbm_tmp < 1e10:
                peak_power_dbm_list[num_vals] = power_dbm_tmp
                num_vals += 1

        # return averaged reading
        peak_power_dbm_avg = np.mean(peak_power_dbm_list)
        return peak_power_dbm_avg

    @rpc(flags={"async"})
    def update_results(self, *args):
        """
        Records data from the main sequence in the experiment dataset.

        Parameters passed to this function will be converted into a 1D array and added to the dataset.
        For efficiency, data is added by mutating indices of a preallocated dataset.
        Contains an internal iterator to keep track of the current index.
        """
        self.mutate_dataset('results', self._result_iter, np.array(args))
        self.set_dataset('management.completion_pct', round(100. * self._result_iter / len(self.results), 3),
                         broadcast=True, persist=True, archive=False)
        self._result_iter += 1

    def analyze(self):
        """
        Analyze the results from the experiment.
        """
        # reenable spec anal display
        self.sa.gpib_write('DISP:ENAB 1')

        # save and process results as necessary
        self._save_results()

    def _save_results(self):
        pass
        # store calibration timestamp
        # calib_timestamp = datetime.timestamp(datetime.now())
        # self.set_dataset('calibration.eggs.transmission.calibration_timestamp', calib_timestamp, broadcast=True, persist=True)

        # copy calibration results to temporary array for convenience
        # power_dataset_tmp = np.array(self.eggs_resonance_calibration)

        # convert power to normalized amplitude values
        # norm_ampl_dataset = np.zeros((2, len(power_dataset_tmp)))
        # norm_ampl_dataset[:, 0] = power_dataset_tmp[:, 0]
        # norm_ampl_dataset[:, 1] = 10 ** (power_dataset_tmp[:, 1] / 20)
        # norm_ampl_dataset[:, 1] /= np.max(power_dataset_tmp[:, 1])
        # self.set_dataset('calibration.eggs.transmission.resonance_ratio_curve_mhz', norm_ampl_dataset, persist=True, broadcast=True)

        # add data to data vault for visualization
        # self.dv.add(np.array([power_dataset_tmp[:, 0], power_dataset_tmp[:, 1], norm_ampl_dataset[:, 1]]).transpose(), context=self.cr)
